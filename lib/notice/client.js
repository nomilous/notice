// Generated by CoffeeScript 1.6.3
var Connector, connector, createClient, defer, deferred, hostname, notifier, testable;

deferred = require('also').deferred;

notifier = require('./notifier');

Connector = require('./connector');

hostname = require('os').hostname;

testable = void 0;

module.exports._client = function() {
  return testable;
};

module.exports.client = function(config) {
  var api, local;
  if (config == null) {
    config = {};
  }
  testable = local = {
    Notifier: notifier.notifier(config),
    clients: {},
    create: deferred(function(_arg, clientName, opts, callback) {
      var client, connect, error, notify, reject, resolve, socket;
      reject = _arg.reject, resolve = _arg.resolve, notify = _arg.notify;
      if (opts == null) {
        opts = {};
      }
      if (typeof clientName !== 'string') {
        error = new Error('Client.create( clientName, opts ) requires clientName as string');
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      if (local.clients[clientName] != null) {
        error = new Error("Client.create( '" + clientName + "', opts ) is already defined");
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      if (!((opts.connect != null) && typeof opts.connect.port === 'number')) {
        error = new Error("Client.create( '" + clientName + "', opts ) requires opts.connect.port");
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      try {
        client = local.clients[clientName] = local.Notifier.create(clientName);
      } catch (_error) {
        error = _error;
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      opts.context || (opts.context = {});
      opts.context.hostname = hostname();
      opts.context.pid = process.pid;
      socket = void 0;
      connect = function() {
        var already;
        socket = Connector.connect(opts.connect);
        client.connection || (client.connection = {});
        client.connection.state = 'pending';
        client.connection.stateAt = Date.now();
        already = false;
        socket.on('connect', function() {
          if (client.connection.state === 'interrupted') {
            client.connection.state = 'resuming';
            client.connection.stateAt = Date.now();
            socket.emit('resume', clientName, opts.connect.secret || '', opts.context || {});
            return;
          }
          client.connection.state = 'connecting';
          client.connection.stateAt = Date.now();
          return socket.emit('handshake', clientName, opts.connect.secret || '', opts.context || {});
        });
        socket.on('accept', function() {
          var _base;
          if (client.connection.state === 'resuming') {
            client.connection.state = 'accepted';
            client.connection.stateAt = Date.now();
            (_base = client.connection).interruptions || (_base.interruptions = {
              count: 0
            });
            client.connection.interruptions.count++;
            return;
          }
          client.connection.state = 'accepted';
          client.connection.stateAt = Date.now();
          resolve(client);
          if (typeof callback === 'function') {
            return callback(null, client);
          }
        });
        socket.on('reject', function(rejection) {
          error = new Error("notice '" + clientName + "' rejected - " + rejection.reason + " from " + rejection.pid + "." + rejection.hostname);
          reject(error);
          if (typeof callback === 'function') {
            if (!already) {
              callback(error);
            }
            return already = true;
          }
        });
        socket.on('disconnect', function() {
          if (client.connection.state !== 'accepted') {
            delete local.clients[clientName];
            error = new Error("Client.create( '" + clientName + "', opts ) failed connect or bad secret");
            reject(error);
            if (typeof callback === 'function') {
              if (!already) {
                callback(error);
              }
              already = true;
            }
            return;
          }
          client.connection.state = 'interrupted';
          return client.connection.stateAt = Date.now();
        });
        return socket.on('error', function(error) {
          if (!((client.connection != null) && client.connection.state === 'pending')) {
            console.log('TODO: handle socket error after connect|accept');
            console.log(error);
            return;
          }
          delete local.clients[clientName];
          setTimeout((function() {
            reject(error);
            if (typeof callback === 'function') {
              if (!already) {
                callback(error);
              }
              return already = true;
            }
          }), opts.connect.errorWait || 2000);
        });
      };
      return connect();
    })
  };
  return api = {
    create: local.create
  };
};

return;

connector = require('./connector');

notifier = require('./notifier');

defer = require('when').defer;

createClient = function(title, opts) {
  var notice;
  notice = notifier.create(title);
  return {
    onAssign: function(_arg) {
      var assigning, socket;
      socket = _arg.socket;
      assigning = defer();
      process.nextTick(function() {
        var event, _fn, _i, _len, _ref;
        notice.first = function(msg, next) {
          msg.direction = 'out';
          return next();
        };
        notice.last = function(msg, next) {
          var type;
          if (msg.direction === 'out') {
            type = msg.context.type;
            socket.emit(type, msg.context, msg);
          }
          return next();
        };
        _ref = ['info', 'event'];
        _fn = function(event) {
          return socket.on(event, function(context, msg) {
            var tenor;
            msg.direction = 'in';
            msg.origin = context.origin;
            title = context.title;
            tenor = context.tenor;
            return notice[event][tenor](title, msg);
          });
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          event = _ref[_i];
          _fn(event);
        }
        return assigning.resolve(notice);
      });
      return assigning.promise;
    },
    onConnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('connect');
    },
    onReconnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('reconnect');
    },
    onDisconnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('disconnect');
    }
  };
};

module.exports = {
  connect: function(title, opts, callback) {
    var client;
    client = createClient(title, opts);
    return connector.connect({
      loglevel: opts.connect.loglevel,
      secret: opts.connect.secret,
      transport: opts.connect.transport,
      address: opts.connect.address,
      port: opts.connect.port,
      origin: opts.origin,
      onAssign: client.onAssign,
      onConnect: client.onConnect,
      onReconnect: client.onReconnect,
      onDisconnect: client.onDisconnect
    }, callback);
  }
};
