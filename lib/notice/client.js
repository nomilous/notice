// Generated by CoffeeScript 1.6.3
var connector, createClient, defer, notifier;

connector = require('./connector');

notifier = require('./notifier');

defer = require('when').defer;

createClient = function(title, opts) {
  var notice;
  notice = notifier.create(title);
  return {
    assign: function(deferral, uplink, callback) {
      var event, _fn, _i, _len, _ref;
      notice.first = function(msg, next) {
        msg.direction = 'out';
        return next();
      };
      notice.last = function(msg, next) {
        var type;
        if (msg.direction === 'out') {
          type = msg.context.type;
          uplink.emit(type, msg.context, msg);
        }
        return next();
      };
      _ref = ['info', 'event'];
      _fn = function(event) {
        return uplink.on(event, function(context, msg) {
          var tenor;
          msg.direction = 'in';
          msg.origin = context.origin;
          title = context.title;
          tenor = context.tenor;
          return notice[event][tenor](title, msg);
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        event = _ref[_i];
        _fn(event);
      }
      deferral.resolve();
      return callback(null, notice);
    },
    onConnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('connect');
    },
    onReconnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('reconnect');
    },
    onDisconnect: function(_arg) {
      var socket;
      socket = _arg.socket;
      return notice.event('disconnect');
    }
  };
};

module.exports = {
  connect: function(title, opts, callback) {
    var client;
    client = createClient(title, opts);
    return connector.connect({
      loglevel: opts.connect.loglevel,
      secret: opts.connect.secret,
      transport: opts.connect.transport,
      address: opts.connect.address,
      port: opts.connect.port,
      onConnect: client.onConnect,
      onReconnect: client.onReconnect,
      onDisconnect: client.onDisconnect
    }, function(error, uplink) {
      var assigning;
      assigning = defer();
      process.nextTick(function() {
        if (error != null) {
          assigning.reject(error);
          return callback(error);
        }
        return client.assign(assigning, uplink, callback);
      });
      return assigning.promise;
    });
  }
};
