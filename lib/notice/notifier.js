// Generated by CoffeeScript 1.6.3
var deferred, message, pipeline, testable, _ref,
  __slice = [].slice;

_ref = require('also'), pipeline = _ref.pipeline, deferred = _ref.deferred;

message = require('./message').message;

testable = void 0;

module.exports._notifier = function() {
  return testable;
};

module.exports.notifier = function(config) {
  var api, local, type;
  if (config == null) {
    config = {};
  }
  if (config.messages == null) {
    config.messages = {
      event: {}
    };
  }
  testable = local = {
    messageTypes: {},
    middleware: {},
    create: function(originCode) {
      var list, notifier, regSequence, traverse, type, _fn;
      if (typeof originCode !== 'string') {
        throw new Error('Notifier.create(originCode) requires originCode as string');
      }
      if (local.middleware[originCode] != null) {
        throw new Error("Notifier.create('" + originCode + "') is already defined");
      }
      regSequence = 0;
      local.middleware[originCode] = list = {};
      traverse = function(message) {
        var title;
        if (!regSequence) {
          return message;
        }
        return pipeline((function() {
          var _results;
          _results = [];
          for (title in list) {
            _results.push((function(title) {
              return deferred(function(_arg, msg) {
                var error, notify, reject, resolve;
                resolve = _arg.resolve, reject = _arg.reject, notify = _arg.notify;
                if (msg == null) {
                  msg = message;
                }
                try {
                  return list[title](msg, function() {
                    return resolve(msg);
                  });
                } catch (_error) {
                  error = _error;
                  return reject(error);
                }
              });
            })(title));
          }
          return _results;
        })());
      };
      notifier = {
        use: function(opts, fn) {
          if (typeof opts === 'function') {
            return list[++regSequence] = opts;
          } else {
            if (!((opts != null) && (opts.title != null) && (fn != null) && typeof fn === 'function')) {
              throw new Error("Notifier.use(opts, fn) requires opts.title and fn");
            }
            list[opts.title] = fn;
            return regSequence++;
          }
        }
      };
      _fn = function(type) {
        return notifier[type] = deferred(function() {
          var args, notify, payload, reject, resolve, _ref1;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _ref1 = args[0], resolve = _ref1.resolve, reject = _ref1.reject, notify = _ref1.notify;
          payload = {};
          payload._type = type;
          if ((typeof args[1]).match(/string|number/)) {
            payload[type] = args[1];
          }
          return pipeline([
            function() {
              return local.messageTypes[type].create(payload);
            }, function(msg) {
              return traverse(msg);
            }
          ]).then(function(msg) {
            resolve(msg);
            if (typeof callback !== "undefined" && callback !== null) {
              return callback(null, msg);
            }
          }, function(err) {
            reject(err);
            if (typeof callback !== "undefined" && callback !== null) {
              return callback(err);
            }
          }, notify);
        });
      };
      for (type in config.messages) {
        if (type === 'use') {
          continue;
        }
        _fn(type);
      }
      return notifier;
    }
  };
  for (type in config.messages) {
    local.messageTypes[type] = message(config.messages[type]);
  }
  return api = {
    create: local.create
  };
};
