// Generated by CoffeeScript 1.6.3
var deferred, message, pipeline, testable, _ref,
  __slice = [].slice;

_ref = require('also'), pipeline = _ref.pipeline, deferred = _ref.deferred;

message = require('./capsule/message').message;

testable = void 0;

module.exports._notifier = function() {
  return testable;
};

module.exports.notifier = function(config) {
  var api, local, type;
  if (config == null) {
    config = {};
  }
  if (config.messages == null) {
    config.messages = {
      event: {}
    };
  }
  testable = local = {
    messageTypes: {},
    middleware: {},
    notifiers: {},
    create: function(originCode) {
      var list, notifier, regSequence, traverse, type, _fn;
      if (typeof originCode !== 'string') {
        throw new Error('Notifier.create(originCode) requires originCode as string');
      }
      if (local.middleware[originCode] != null) {
        throw new Error("Notifier.create('" + originCode + "') is already defined");
      }
      regSequence = 0;
      local.middleware[originCode] = list = {};
      traverse = function(message) {
        var title;
        if (!regSequence) {
          return message;
        }
        return pipeline((function() {
          var _results;
          _results = [];
          for (title in list) {
            _results.push((function(title) {
              return deferred(function(_arg, msg) {
                var error, notify, reject, resolve;
                resolve = _arg.resolve, reject = _arg.reject, notify = _arg.notify;
                if (msg == null) {
                  msg = message;
                }
                try {
                  return list[title]((function() {
                    return resolve(msg);
                  }), msg);
                } catch (_error) {
                  error = _error;
                  return reject(error);
                }
              });
            })(title));
          }
          return _results;
        })());
      };
      local.notifiers[originCode] = notifier = {
        use: function(opts, fn) {
          if (typeof opts === 'function') {
            return list[++regSequence] = opts;
          } else {
            if (!((opts != null) && (opts.title != null) && (fn != null) && typeof fn === 'function')) {
              throw new Error("Notifier.use(opts, fn) requires opts.title and fn");
            }
            list[opts.title] = fn;
            return regSequence++;
          }
        }
      };
      _fn = function(type) {
        return notifier[type] = deferred(function() {
          var arg, args, callback, key, notify, payload, reject, resolve, _i, _len, _ref1;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _ref1 = args.shift(), resolve = _ref1.resolve, reject = _ref1.reject, notify = _ref1.notify;
          payload = {};
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            if ((typeof arg).match(/string|number/)) {
              if (payload[type] != null) {
                payload.description = arg;
              } else {
                payload[type] = arg;
              }
              continue;
            }
            if (arg instanceof Array) {
              continue;
            }
            for (key in arg) {
              if (key === type && (payload[key] != null)) {
                continue;
              }
              payload[key] = arg[key];
            }
          }
          if (typeof arg === 'function') {
            callback = arg;
          }
          return pipeline([
            function() {
              return local.messageTypes[type].create(payload);
            }, function(msg) {
              return traverse(msg);
            }
          ]).then(function(msg) {
            resolve(msg);
            if (callback != null) {
              return callback(null, msg);
            }
          }, function(err) {
            reject(err);
            if (callback != null) {
              return callback(err);
            }
          }, notify);
        });
      };
      for (type in config.messages) {
        if (type === 'use') {
          continue;
        }
        _fn(type);
      }
      return notifier;
    }
  };
  for (type in config.messages) {
    local.messageTypes[type] = message(type, config);
  }
  return api = {
    create: local.create
  };
};
