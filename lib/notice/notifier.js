// Generated by CoffeeScript 1.6.3
var deferred, health, invalidAction, lifecycle, middleware, pipeline, testable, undefinedArg, v1, _ref, _ref1,
  __slice = [].slice;

_ref = require('also'), pipeline = _ref.pipeline, deferred = _ref.deferred;

lifecycle = require('./capsule/lifecycle').lifecycle;

health = require('../api/health').health;

middleware = require('../api/middleware').middleware;

v1 = require('node-uuid').v1;

_ref1 = require('./errors'), undefinedArg = _ref1.undefinedArg, invalidAction = _ref1.invalidAction;

testable = void 0;

module.exports._notifier = function() {
  return testable;
};

module.exports.notifier = function(config) {
  var api, local, type, _base;
  if (config == null) {
    config = {};
  }
  if (config.capsule == null) {
    config.capsule = {
      event: {}
    };
  }
  config.error || (config.error = {});
  if ((_base = config.error).keep == null) {
    _base.keep = 10;
  }
  config.capsule.$$control = {};
  config.capsule.$$delta = {};
  config.capsule.$$tick = {};
  config.capsule.$$health = {
    before: function(done, capsule) {
      return health(capsule, function() {
        return done();
      });
    }
  };
  testable = local = {
    capsuleTypes: {},
    notifiers: {},
    notifierMetrics: {},
    middleware: {},
    create: function(title, uuid) {
      var collection, keepErrors, localErrors, localMetrics, nfMetrics, notifier, tooManyErrorsToKeep, traverse, type, _fn;
      if (uuid == null) {
        uuid = v1();
      }
      if (typeof title !== 'string') {
        throw new Error('Notifier.create(title) requires title as string');
      }
      if (local.middleware[title] != null) {
        throw new Error("Notifier.create('" + title + "') is already defined");
      }
      local.middleware[title] = collection = middleware(config);
      local.notifierMetrics[title] = nfMetrics = {
        pipeline: localMetrics = {
          input: {
            count: 0
          },
          processing: {
            count: 0
          },
          output: {
            count: 0
          },
          error: {
            usr: 0,
            sys: 0
          },
          cancel: {
            usr: 0,
            sys: 0
          }
        },
        errors: localErrors = {
          recent: []
        }
      };
      tooManyErrorsToKeep = function() {
        return localErrors.recent.length > config.error.keep;
      };
      keepErrors = function(title, type, error) {
        var _results;
        localErrors.recent.push({
          timestamp: new Date,
          error: error.toString(),
          middleware: {
            title: title,
            type: type
          }
        });
        _results = [];
        while (tooManyErrorsToKeep()) {
          _results.push(localErrors.recent.shift());
        }
        return _results;
      };
      traverse = function(capsule) {
        var cancelled, functions, mware, traversal;
        traversal = {};
        traversal.cache = notifier.cache;
        traversal.tools = notifier.tools;
        cancelled = false;
        localMetrics.input.count++;
        localMetrics.processing.count++;
        functions = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = collection.running();
          _results = [];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            mware = _ref2[_i];
            _results.push((function(mware) {
              return deferred(function(action) {
                var error, fn, next, notify, reject, resolve, type;
                resolve = action.resolve, reject = action.reject, notify = action.notify;
                type = mware.type, title = mware.title, fn = mware.fn;
                next = function() {
                  return process.nextTick(function() {
                    return resolve(capsule);
                  });
                };
                next.notify = function(update) {
                  return process.nextTick(function() {
                    return notify(update);
                  });
                };
                next.reject = function(error) {
                  keepErrors(title, type, error);
                  localMetrics.processing.count--;
                  if (type === 'usr') {
                    localMetrics.error.usr++;
                  }
                  if (type === 'sys') {
                    localMetrics.error.sys++;
                  }
                  return process.nextTick(function() {
                    return reject(error);
                  });
                };
                next.cancel = function() {
                  cancelled = true;
                  localMetrics.processing.count--;
                  if (type === 'usr') {
                    localMetrics.cancel.usr++;
                  }
                  if (type === 'sys') {
                    localMetrics.cancel.sys++;
                  }
                  return process.nextTick(function() {
                    return notify({
                      _type: 'control',
                      control: 'cancel',
                      middleware: title,
                      capsule: capsule
                    });
                  });
                };
                try {
                  fn(next, capsule, traversal);
                  if (title === 'last' && !cancelled) {
                    localMetrics.output.count++;
                    return localMetrics.processing.count--;
                  }
                } catch (_error) {
                  error = _error;
                  keepErrors(title, type, error);
                  if (type === 'usr') {
                    localMetrics.error.usr++;
                  }
                  if (type === 'sys') {
                    localMetrics.error.sys++;
                  }
                  localMetrics.processing.count--;
                  return reject(error);
                }
              });
            })(mware));
          }
          return _results;
        })();
        return pipeline(functions);
      };
      local.notifiers[title] = notifier = {
        use: function(opts, fn) {
          if (opts.update === true) {
            return collection.update(opts);
          }
          if (opts.enabled == null) {
            opts.enabled = true;
          }
          if (!((opts != null) && (opts.title != null) && (fn != null) && typeof fn === 'function')) {
            throw undefinedArg('opts.title and fn', 'use(opts, middlewareFn)');
          }
          if (!(opts.first || opts.last)) {
            if (opts.title === 'first' || opts.title === 'last') {
              process.stderr.write("notice: 'first' and 'last' are reserved middleware titles\n");
              return;
            }
          }
          if (opts.last != null) {
            return collection.last(fn);
          }
          if (opts.first != null) {
            return collection.first(fn);
          }
          return collection.create({
            slot: opts.slot,
            title: opts.title,
            description: opts.description,
            enabled: opts.enabled,
            fn: fn
          });
        }
      };
      Object.defineProperty(notifier, 'uuid', {
        writable: false,
        enumerable: true,
        value: uuid
      });
      Object.defineProperty(notifier, 'title', {
        writable: false,
        enumerable: true,
        value: title
      });
      Object.defineProperty(notifier, 'uniqueTitle', {
        get: function() {
          return function(title) {
            var list, slot;
            list = collection.list();
            for (slot in list) {
              if (list[slot].title === title) {
                return false;
              }
            }
            return true;
          };
        }
      });
      Object.defineProperty(notifier, 'lastSlot', {
        get: function() {
          var list, slot;
          list = collection.list();
          for (slot in list) {
            slot;
          }
          return slot;
        }
      });
      Object.defineProperty(notifier, 'serialize', {
        value: function(detail) {
          var middlewares;
          if (detail == null) {
            detail = 1;
          }
          switch (detail) {
            case 1:
              return {
                title: notifier.title,
                uuid: notifier.uuid,
                stats: {
                  pipeline: nfMetrics.pipeline
                }
              };
            case 2:
              middlewares = local.middleware[notifier.title];
              return {
                title: notifier.title,
                uuid: notifier.uuid,
                stats: {
                  pipeline: nfMetrics.pipeline
                },
                cache: notifier.cache,
                tools: notifier.tools,
                errors: nfMetrics.errors,
                middlewares: collection.list()
              };
          }
        }
      });
      Object.defineProperty(notifier, '$$raw', {
        get: function() {
          return function(payload) {
            return traverse(payload);
          };
        }
      });
      _fn = function(type) {
        return notifier[type] = deferred(function() {
          var arg, args, callback, key, notify, payload, reject, resolve, _i, _len, _ref2;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          _ref2 = args.shift(), resolve = _ref2.resolve, reject = _ref2.reject, notify = _ref2.notify;
          payload = {};
          for (_i = 0, _len = args.length; _i < _len; _i++) {
            arg = args[_i];
            if ((typeof arg).match(/string|number/)) {
              if (payload[type] != null) {
                payload.description = arg;
              } else {
                payload[type] = arg;
              }
              continue;
            }
            if (arg instanceof Array) {
              continue;
            }
            for (key in arg) {
              if (key === type && (payload[key] != null)) {
                continue;
              }
              payload[key] = arg[key];
            }
          }
          if (typeof arg === 'function') {
            callback = arg;
          }
          return pipeline([
            function() {
              return local.capsuleTypes[type].create(payload);
            }, function(capsule) {
              return traverse(capsule);
            }
          ]).then(function(capsule) {
            resolve(capsule);
            if (callback != null) {
              return callback(null, capsule);
            }
          }, function(err) {
            reject(err);
            if (callback != null) {
              return callback(err);
            }
          }, notify);
        });
      };
      for (type in config.capsule) {
        if (notifier[type] != null) {
          continue;
        }
        _fn(type);
      }
      return notifier;
    }
  };
  for (type in config.capsule) {
    local.capsuleTypes[type] = lifecycle(type, config);
  }
  return api = {
    create: local.create
  };
};
