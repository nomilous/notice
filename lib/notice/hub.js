// Generated by CoffeeScript 1.6.3
var Listener, Notifier, deferred, listen, notifier, testable;

deferred = require('also').deferred;

Listener = require('./listener');

notifier = require('./notifier');

testable = void 0;

module.exports._hub = function() {
  return testable;
};

module.exports.hub = function(config) {
  var api, local;
  if (config == null) {
    config = {};
  }
  testable = local = {
    Notifier: notifier.notifier(config),
    hubs: {},
    clients: {},
    name2id: {},
    connections: function() {
      var client, id;
      console.log('---------');
      for (id in local.clients) {
        client = local.clients[id];
        console.log(client.title, client.context, client.connected);
      }
      return console.log('---------');
    },
    create: deferred(function(_arg, hubName, opts, callback) {
      var error, hub, io, notify, reject, resolve;
      reject = _arg.reject, resolve = _arg.resolve, notify = _arg.notify;
      if (opts == null) {
        opts = {};
      }
      if (typeof hubName !== 'string') {
        error = new Error('Hub.create( hubName, opts ) requires hubName as string');
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      if (local.hubs[hubName] != null) {
        error = new Error("Hub.create( '" + hubName + "', opts ) is already defined");
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      try {
        local.hubs[hubName] = hub = local.Notifier.create(hubName);
      } catch (_error) {
        error = _error;
        reject(error);
        if (typeof callback === 'function') {
          callback(error);
        }
        return;
      }
      io = Listener.listen(opts.listen, function(error, address) {
        if (error != null) {
          reject(error);
          if (typeof callback === 'function') {
            callback(error);
          }
          return;
        }
        hub.listening = address;
        resolve(hub);
        if (typeof callback === 'function') {
          return callback(null, hub);
        }
      });
      return io.on('connection', function(socket) {
        var id;
        id = socket.id;
        socket.on('handshake', function(originName, secret, context) {
          var client, previousID;
          if (secret !== opts.listen.secret) {
            return socket.disconnect();
          }
          if (previousID = local.name2id[originName]) {
            client = local.clients[previousID];
            if (client.connected.state === 'connected') {
              socket.emit('reject', {
                reason: 'already connected',
                hostname: client.context.hostname,
                pid: client.context.pid
              });
              socket.disconnect();
              local.connections();
              return;
            }
            delete local.clients[previousID];
            delete local.name2id[originName];
            local.clients[id] = client;
          } else {
            local.clients[socket.id] = client = {
              title: originName,
              context: context,
              hub: hubName,
              socket: socket
            };
          }
          client.connected || (client.connected = {});
          client.connected.state = 'connected';
          client.connected.stateAt = Date.now();
          client.context.hostname = context.hostname;
          client.context.pid = context.pid;
          local.name2id[originName] = id;
          socket.emit('accept');
          return local.connections();
        });
        socket.on('resume', function(originName, secret, context) {
          var client, previousID;
          if (secret !== opts.listen.secret) {
            return socket.disconnect();
          }
          if (previousID = local.name2id[originName]) {
            client = local.clients[previousID];
            delete local.clients[previousID];
            delete local.name2id[originName];
            local.clients[id] = client;
          } else {
            local.clients[socket.id] = client = {
              title: originName,
              context: context,
              hub: hubName
            };
          }
          client.connected || (client.connected = {});
          client.connected.state = 'connected';
          client.connected.stateAt = Date.now();
          client.context.hostname = context.hostname;
          client.context.pid = context.pid;
          local.name2id[originName] = id;
          socket.emit('accept');
          return local.connections();
        });
        return socket.on('disconnect', function() {
          var client;
          try {
            client = local.clients[id];
          } catch (_error) {}
          if (client == null) {
            return;
          }
          client.connected.state = 'disconnected';
          client.connected.stateAt = Date.now();
          return local.connections();
        });
      });
    })
  };
  return api = {
    create: local.create
  };
};

return;

listen = require('./listen');

Notifier = require('./notifier');

module.exports.create = function(hubName, opts, callback) {
  var assignResponder, inbound, io, responders, _base;
  if (typeof hubName !== 'string') {
    throw new Error('Notifier.listen( hubName, opts ) requires hubName as string');
  }
  responders = {};
  assignResponder = function(origin, socket, callback) {
    var responder;
    if (!(responder = responders[socket.id])) {
      responder = Notifier.create(hubName);
      responder.first = function(msg, next) {
        msg.direction = 'out';
        return next();
      };
      responder.last = function(msg, next) {
        var type;
        type = msg.context.type;
        socket.emit(type, msg.context, msg);
        return next();
      };
      responders[socket.id] = {
        notice: responder,
        origin: origin,
        connected: true
      };
    }
    return callback();
  };
  opts || (opts = {});
  opts.listen || (opts.listen = {});
  (_base = opts.listen).secret || (_base.secret = '');
  opts.hub = {};
  inbound = Notifier.create(hubName);
  inbound.use(function(msg, next) {
    var responder;
    responder = responders[msg['socket.id']];
    msg.setResponder = responder.notice;
    Object.defineProperty(msg, 'originContext', {
      enumareable: false,
      get: function() {
        return responder.origin;
      }
    });
    delete msg['socket.id'];
    return next();
  });
  io = listen({
    loglevel: opts.listen.loglevel,
    address: opts.listen.address,
    port: opts.listen.port,
    cert: opts.listen.cert,
    key: opts.listen.key
  }, function(error, address) {
    opts.listening = address;
    if (typeof callback === 'function') {
      return callback(error, inbound);
    }
  });
  return io.on('connection', function(socket) {
    var event, _fn, _i, _len, _ref;
    socket.on('handshake', function(secret, origin) {
      if (secret === opts.listen.secret) {
        return assignResponder(origin, socket, function() {
          return socket.emit('accept');
        });
      } else {
        return socket.disconnect();
      }
    });
    _ref = ['info', 'event'];
    _fn = function(event) {
      return socket.on(event, function(context, msg) {
        var tenor, title;
        msg.direction = 'in';
        msg.origin = context.origin;
        title = context.title;
        tenor = context.tenor;
        msg['socket.id'] = socket.id;
        return inbound[event][tenor](title, msg);
      });
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      _fn(event);
    }
    return socket.on('disconnect', function() {
      var responder;
      if (responder = responders[socket.id]) {
        responder.notice.event('disconnect');
        return responder.connected = false;
      }
    });
  });
};
