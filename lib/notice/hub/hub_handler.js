// Generated by CoffeeScript 1.6.3
var PROTOCOL_VERSION, Testable, testable;

PROTOCOL_VERSION = 1;

Testable = void 0;

testable = void 0;

module.exports._Handler = function() {
  return Testable;
};

module.exports._handler = function() {
  return testable;
};

module.exports.handler = function(config) {
  var Capsule, Handler, api;
  if (config == null) {
    config = {};
  }
  Capsule = require('../capsule/capsule').capsule();
  Testable = Handler = {
    create: function(hubName, hubNotifier, hubContext, opts) {
      var handler;
      hubNotifier.use({
        title: 'inbound socket interface',
        first: true
      }, function(next, capsule, traversal) {
        var client, id;
        if (!(id = capsule._socket_id)) {
          next();
        }
        delete capsule._socket_id;
        try {
          client = hubContext.clients[id];
          traversal.origin = client;
        } catch (_error) {}
        return next();
      });
      return testable = handler = {
        assign: function(socket) {
          var type, _results;
          _results = [];
          for (type in config.capsule) {
            if (type === 'control') {
              continue;
            }
            _results.push((function(type) {
              return socket.on(type, function(payload) {
                if (typeof hubNotifier[type] !== 'function') {
                  process.stderr.write("notice undefined capsule type '" + type + "'");
                  return;
                }
                return hubNotifier[type](payload);
              });
            })(type));
          }
          return _results;
        },
        disconnect: function(socket) {
          return function() {
            var client, id;
            id = socket.id;
            try {
              client = hubContext.clients[id];
            } catch (_error) {}
            if (client == null) {
              return;
            }
            client.connection || (client.connection = {});
            client.connection.state = 'disconnected';
            client.connection.stateAt = Date.now();
            hubNotifier.control('suspend', {
              _socket_id: id
            });
            return hubContext.connections();
          };
        },
        capsule: function(socket) {
          /* grep PROTOCOL1 decode*/

          var id, mismatch;
          id = socket.id;
          mismatch = false;
          return function(header, control, payload) {
            var assign, capsule, client, hidden, property, tected, uuid, version, who;
            version = header[0];
            uuid = control.uuid;
            if (version !== PROTOCOL_VERSION) {
              try {
                client = hubContext.clients[id];
                who = "" + client.context.pid + "." + client.context.hostname;
              } catch (_error) {}
              if (!mismatch) {
                process.stderr.write("notice: protocol mismatch - thishub:" + PROTOCOL_VERSION + " client:" + version + " " + who + "\n");
                mismatch = true;
              }
              return socket.emit('nak', {
                uuid: control.uuid,
                reason: 'protocol mismatch',
                support: [PROTOCOL_VERSION]
              });
            }
            socket.emit('ack', {
              uuid: control.uuid
            });
            try {
              tected = control["protected"];
            } catch (_error) {}
            try {
              hidden = control.hidden;
            } catch (_error) {}
            capsule = new Capsule({
              uuid: uuid || 'moo'
            });
            for (property in payload) {
              assign = {};
              assign[property] = payload[property];
              if (hidden[property]) {
                assign.hidden = true;
              }
              if (tected[property]) {
                assign["protected"] = true;
              }
              capsule.set(assign);
            }
            capsule._socket_id = id;
            return hubNotifier.raw(capsule);
          };
        },
        handshake: function(socket) {
          return function(originTitle, secret, context) {
            var previousID;
            if (secret !== opts.listen.secret) {
              return handler.reject(socket, {
                reason: 'bad secret'
              });
            }
            if (previousID = hubContext.name2id[originTitle]) {
              return handler.handleExisting('start', socket, previousID, originTitle, context);
            }
            return handler.handleNew('start', socket, originTitle, context);
          };
        },
        resume: function(socket) {
          return function(originTitle, secret, context) {
            var previousID;
            if (secret !== opts.listen.secret) {
              return handler.reject(socket, {
                reason: 'bad secret'
              });
            }
            if (previousID = hubContext.name2id[originTitle]) {
              return handler.handleExisting('resume', socket, previousID, originTitle, context);
            }
            return handler.handleNew('resume', socket, originTitle, context);
          };
        },
        accept: function(startOrResume, newSocket, client, originTitle, newContext) {
          var id, key;
          id = newSocket.id;
          hubContext.clients[id] = client;
          client.connection || (client.connection = {});
          client.connection.state = 'connected';
          client.connection.stateAt = Date.now();
          for (key in newContext) {
            client.context[key] = newContext[key];
          }
          hubNotifier.control(startOrResume, {
            _socket_id: id
          });
          hubContext.name2id[originTitle] = id;
          newSocket.emit('accept');
          return hubContext.connections();
        },
        reject: function(socket, details) {
          socket.emit('reject', details);
          socket.disconnect();
        },
        handleNew: function(startOrResume, socket, originTitle, context) {
          var client;
          client = {
            title: originTitle,
            context: context,
            hub: hubName
          };
          Object.defineProperty(client, 'socket', {
            enumerable: false,
            get: function() {
              process.stderr.write("notice: capacity to use the client socket directly is unlikely permanent functionality");
              return socket;
            }
          });
          handler.assign(socket);
          return handler.accept(startOrResume, socket, client, originTitle, context);
        },
        handleExisting: function(startOrResume, newSocket, previousID, originTitle, newContext) {
          var client;
          client = hubContext.clients[previousID];
          if (client.connection.state === 'connected') {
            newSocket.emit('reject', {
              reason: 'already connected',
              hostname: client.context.hostname,
              pid: client.context.pid
            });
            newSocket.disconnect();
            hubContext.connections();
            return;
          }
          delete hubContext.clients[previousID];
          delete hubContext.name2id[originTitle];
          handler.assign(newSocket);
          return handler.accept(startOrResume, newSocket, client, originTitle, newContext);
        }
      };
    }
  };
  return api = {
    create: Handler.create
  };
};
