// Generated by CoffeeScript 1.6.3
var Testable, testable;

Testable = void 0;

testable = void 0;

module.exports._Handler = function() {
  return Testable;
};

module.exports._handler = function() {
  return testable;
};

module.exports.handler = function(config) {
  var Handler, api;
  if (config == null) {
    config = {};
  }
  Testable = Handler = {
    create: function(hubName, hubNotifier, hubContext, opts) {
      var handler;
      return testable = handler = {
        assign: function(socket) {
          var type, _results;
          _results = [];
          for (type in config.messages) {
            if (type === 'control') {
              continue;
            }
            _results.push((function(type) {
              return socket.on(type, function(payload) {
                if (typeof hubNotifier[type] !== 'function') {
                  process.stderr.write("notice undefined message type '" + type + "'");
                  return;
                }
                return hubNotifier[type](payload);
              });
            })(type));
          }
          return _results;
        },
        disconnect: function(socket) {
          return function() {
            var client, id;
            id = socket.id;
            try {
              client = hubContext.clients[id];
            } catch (_error) {}
            if (client == null) {
              return;
            }
            client.connected.state = 'disconnected';
            client.connected.stateAt = Date.now();
            hubNotifier.control('suspend', {
              client: client.context
            });
            return hubContext.connections();
          };
        },
        handshake: function(socket) {
          return function(originName, secret, context) {
            var previousID;
            if (secret !== opts.listen.secret) {
              return handler.reject(socket, {
                reason: 'bad secret'
              });
            }
            if (previousID = hubContext.name2id[originName]) {
              return handler.handleExisting('start', socket, previousID, originName, context);
            }
            return handler.handleNew('start', socket, originName, context);
          };
        },
        resume: function(socket) {
          return function(originName, secret, context) {
            var previousID;
            if (secret !== opts.listen.secret) {
              return handler.reject(socket, {
                reason: 'bad secret'
              });
            }
            if (previousID = hubContext.name2id[originName]) {
              return handler.handleExisting('resume', socket, previousID, originName, context);
            }
            return handler.handleNew('resume', socket, originName, context);
          };
        },
        accept: function(startOrResume, newSocket, client, originName, newContext) {
          var id, key;
          id = newSocket.id;
          hubContext.clients[id] = client;
          client.connected || (client.connected = {});
          client.connected.state = 'connected';
          client.connected.stateAt = Date.now();
          for (key in newContext) {
            client.context[key] = newContext[key];
          }
          client.context.origin = originName;
          hubNotifier.control(startOrResume, {
            client: client.context
          });
          hubContext.name2id[originName] = id;
          newSocket.emit('accept');
          return hubContext.connections();
        },
        reject: function(socket, details) {
          socket.emit('reject', details);
          socket.disconnect();
        },
        handleNew: function(startOrResume, socket, originName, context) {
          var client;
          client = {
            title: originName,
            context: context,
            hub: hubName,
            socket: socket
          };
          handler.assign(socket);
          return handler.accept(startOrResume, socket, client, originName, context);
        },
        handleExisting: function(startOrResume, newSocket, previousID, originName, newContext) {
          var client;
          client = hubContext.clients[previousID];
          if (client.connected.state === 'connected') {
            newSocket.emit('reject', {
              reason: 'already connected',
              hostname: client.context.hostname,
              pid: client.context.pid
            });
            newSocket.disconnect();
            hubContext.connections();
            return;
          }
          delete hubContext.clients[previousID];
          delete hubContext.name2id[originName];
          handler.assign(newSocket);
          return handler.accept(startOrResume, newSocket, client, originName, newContext);
        }
      };
    }
  };
  return api = {
    create: Handler.create
  };
};
