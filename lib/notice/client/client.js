// Generated by CoffeeScript 1.6.3
var Connector, PROTOCOL_VERSION, alreadyDefined, connectRejected, deferred, disconnected, hostname, notifier, reservedCapsule, terminal, testable, undefinedArg, _ref;

PROTOCOL_VERSION = 1;

hostname = require('os').hostname;

deferred = require('also').deferred;

notifier = require('../notifier');

Connector = require('./connector');

_ref = require('../errors'), terminal = _ref.terminal, reservedCapsule = _ref.reservedCapsule, undefinedArg = _ref.undefinedArg, alreadyDefined = _ref.alreadyDefined, connectRejected = _ref.connectRejected, disconnected = _ref.disconnected;

testable = void 0;

module.exports._client = function() {
  return testable;
};

module.exports.client = function(config) {
  var Capsule, api, local, type;
  if (config == null) {
    config = {};
  }
  for (type in config.capsule) {
    if (type.match(/^connect$|^handshake$|^accept$|^reject$|^disconnect$|^resume$|^capsule$|^nak$|^ack$|^error$/)) {
      throw reservedCapsule(type);
    }
  }
  Capsule = require('../capsule/capsule').capsule();
  testable = local = {
    Notifier: notifier.notifier(config),
    clients: {},
    create: deferred(function(_arg, title, opts, callback) {
      var already, client, error, notify, reject, resolve, socket, transit;
      reject = _arg.reject, resolve = _arg.resolve, notify = _arg.notify;
      if (opts == null) {
        opts = {};
      }
      try {
        if (typeof title === 'object') {
          callback = opts;
          opts = title;
          title = opts.title;
        }
        if (typeof title !== 'string') {
          throw undefinedArg('title');
        }
        if (local.clients[title] != null) {
          throw alreadyDefined('title', title);
        }
        if (!((opts.connect != null) && typeof opts.connect.url === 'string')) {
          throw undefinedArg('opts.connect.url');
        }
        client = local.Notifier.create(title, opts.uuid);
        local.clients[title] = client;
      } catch (_error) {
        error = _error;
        return terminal(error, reject, callback);
      }
      opts.context || (opts.context = {});
      opts.context.hostname = hostname();
      opts.context.pid = process.pid;
      socket = Connector.connect(opts.connect);
      client.connection || (client.connection = {});
      client.connection.state = 'pending';
      client.connection.stateAt = Date.now();
      client.cache = opts.cache || {};
      already = false;
      transit = {};
      client.use({
        title: 'outbound socket interface',
        last: true
      }, function(next, capsule) {
        /* grep PROTOCOL1 encode*/

        var control, header;
        header = [PROTOCOL_VERSION];
        control = {
          type: capsule._type,
          uuid: capsule._uuid,
          "protected": capsule._protected,
          hidden: capsule._hidden
        };
        socket.emit('capsule', header, control, capsule.all);
        transit[capsule._uuid] = {
          next: next
        };
        return process.nextTick(function() {
          return next.notify({
            _type: 'control',
            control: 'transmitted',
            capsule: capsule
          });
        });
      });
      socket.on('capsule', function(header, control, payload) {
        var assign, capsule, hidden, property, tected, uuid, version;
        version = header[0];
        uuid = control.uuid;
        if (version !== PROTOCOL_VERSION) {
          throw new Error("notice: " + reason + " - hub:" + version + " thisclient:" + PROTOCOL_VERSION);
        }
        try {
          tected = control["protected"];
        } catch (_error) {}
        try {
          hidden = control.hidden;
        } catch (_error) {}
        capsule = new Capsule({
          uuid: uuid
        });
        for (property in payload) {
          assign = {};
          assign[property] = payload[property];
          if (hidden[property]) {
            assign.hidden = true;
          }
          if (tected[property]) {
            assign["protected"] = true;
          }
          capsule.set(assign);
        }
        return client.$$raw(capsule);
      });
      socket.on('ack', function(control) {
        var next, uuid;
        try {
          uuid = control.uuid;
          next = transit[uuid].next;
          try {
            delete transit[uuid];
          } catch (_error) {}
        } catch (_error) {
          error = _error;
          process.stderr.write('notice: invalid or unexpected ACK ' + uuid + '\n');
          return;
        }
        return next();
      });
      socket.on('nak', function(control) {
        var next, reason, support, uuid;
        try {
          uuid = control.uuid, reason = control.reason;
          next = transit[uuid].next;
          try {
            delete transit[uuid];
          } catch (_error) {}
        } catch (_error) {
          error = _error;
          process.stderr.write('notice: invalid or unexpected NAK ' + uuid + '\n');
          return;
        }
        switch (reason) {
          case 'protocol mismatch':
            try {
              support = control.support.join(',');
            } catch (_error) {}
            return next.reject(new Error("notice: " + reason + " - hub:" + support + " thisclient:" + PROTOCOL_VERSION));
        }
      });
      socket.on('connect', function() {
        if (client.connection.state === 'interrupted') {
          client.connection.state = 'resuming';
          client.connection.stateAt = Date.now();
          socket.emit('resume', title, opts.connect.secret || '', opts.context || {});
          return;
        }
        client.connection.state = 'connecting';
        client.connection.stateAt = Date.now();
        return socket.emit('handshake', title, opts.connect.secret || '', opts.context || {});
      });
      socket.on('accept', function() {
        var _base;
        if (client.connection.state === 'resuming') {
          client.connection.state = 'accepted';
          client.connection.stateAt = Date.now();
          (_base = client.connection).interruptions || (_base.interruptions = {
            count: 0
          });
          client.connection.interruptions.count++;
          return;
        }
        client.connection.state = 'accepted';
        client.connection.stateAt = Date.now();
        resolve(client);
        if (typeof callback === 'function') {
          return callback(null, client);
        }
      });
      socket.on('reject', function(rejection) {
        /* it may happen that the disconnect occurs before the reject, making the rejection reason 'vanish'*/

        terminal(connectRejected(title, rejection), reject, callback);
        return already = true;
      });
      socket.on('disconnect', function() {
        if (client.connection.state !== 'accepted') {
          delete local.clients[title];
          if (!already) {
            terminal(disconnected(title), reject, callback);
          }
          already = true;
          return;
        }
        client.connection.state = 'interrupted';
        client.connection.stateAt = Date.now();
      });
      return socket.on('error', function(error) {
        if (!((client.connection != null) && client.connection.state === 'pending')) {
          console.log('TODO: handle socket error after connect|accept');
          console.log(error);
          return;
        }
        delete local.clients[title];
        setTimeout((function() {
          reject(error);
          if (typeof callback === 'function') {
            if (!already) {
              callback(error);
            }
            return already = true;
          }
        }), opts.connect.errorWait || 2000);
      });
    })
  };
  return api = {
    create: local.create
  };
};
