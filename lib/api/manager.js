// Generated by CoffeeScript 1.6.3
var Version, authenticator, coffee, missingConfig, readFileSync, recursor, start, testable;

authenticator = require('./authenticator').authenticator;

missingConfig = require('../notice/errors').missingConfig;

start = require('../notice/hub/listener').start;

recursor = require('./recursor').recursor;

readFileSync = require('fs').readFileSync;

coffee = require('coffee-script');

Version = JSON.parse(readFileSync(__dirname + '/../../package.json', 'utf8')).version;

testable = void 0;

module.exports._manager = function() {
  return testable;
};

module.exports.manager = function(config) {
  var address, api, authenticated, listen, local, opts, port, server, transport, _ref;
  if (config == null) {
    config = {};
  }
  try {
    listen = config.api.listen;
  } catch (_error) {}
  authenticated = authenticator(config);
  if (listen == null) {
    throw missingConfig('config.api.listen', 'api');
  }
  if (typeof listen.port !== 'number') {
    throw missingConfig('config.api.listen.port', 'api');
  }
  testable = local = {
    hubContext: void 0,
    register: function(hubContext) {
      return local.hubContext = hubContext;
    },
    methodNotAllowed: function(response) {
      response.writeHead(405);
      return response.end();
    },
    objectNotFound: function(response) {
      response.writeHead(404);
      return response.end();
    },
    unsupportedMedia: function(response) {
      response.writeHead(415);
      return response.end();
    },
    respond: function(data, statusCode, response) {
      var body;
      body = JSON.stringify(data, null, 2);
      response.writeHead(statusCode, {
        'Content-Type': 'application/json',
        'Content-Length': body.length
      });
      response.write(body);
      return response.end();
    },
    badRequest: function(response, data) {
      return local.respond(data, 400, response);
    },
    middleware: function(action, hub, slot, contentType, body, response, statusCode) {
      var error, errorType, js;
      if (!(contentType === 'text/javascript' || contentType === 'text/coffeescript')) {
        return local.unsupportedMedia(response);
      }
      /* 
      
      coffeescript
      ============
      
      curl -u user: -H 'Content-Type: text/coffeescript' :20002/hubs/1/middlewares -d '
      
      title: "title"
      fn: (next, capsule) -> 
          console.log capsule.$all()
          next()
      
      '
      
      curl -u user: -H 'Content-Type: text/coffeescript' :20002/hubs/1/middlewares -d '
      
      title: "title"
      slot:  1
      fn: (next) -> next()
      
      '
      
      curl -u user: -H 'Content-Type: text/coffeescript' :20002/hubs/1/middlewares/10 -d '
      
      title: "title"
      fn: (next) -> next()
      
      '
      
      javascript
      ==========
      
      curl -u user: -H 'Content-Type: text/javascript' :20002/hubs/1/middlewares/10 -d '
      
      { 
          title: "title",
          fn: function(next) {
              next();
          }
      }
      
      '
      */

      try {
        js = contentType === 'text/coffeescript' ? coffee.compile(body, {
          bare: true
        }) : body;
      } catch (_error) {
        error = _error;
        errorType = (function() {
          try {
            return error.constructor.name;
          } catch (_error) {}
        })();
        return local.badRequest(response, {
          error: {
            type: errorType || 'Error',
            message: error.message,
            location: error.location
          }
        });
      }
      try {
        eval("var mware=" + js);
      } catch (_error) {
        error = _error;
        errorType = (function() {
          try {
            return error.constructor.name;
          } catch (_error) {}
        })();
        return local.badRequest(response, {
          error: {
            type: errorType || 'Error',
            message: error.message
          }
        });
      }
      return local[action + 'Middleware'](hub, slot, mware, function(error, result) {
        if (error != null) {
          errorType = (function() {
            try {
              return error.constructor.name;
            } catch (_error) {}
          })();
          return local.badRequest(response, {
            error: {
              type: errorType || 'Error',
              message: error.message,
              suggestion: error.suggestion
            }
          });
        }
        return local.respond(result.middleware, result.statusCode, response);
      });
    },
    insertMiddleware: function(hub, slot, middleware, callback) {
      var error, inserted;
      if (middleware.slot != null) {
        error = new Error('notice: cannot insert middleware with already specified slot');
        error.suggestion = {
          upsert: '[POST,PUT] /hubs/:uuid:/middlewares/:slot:'
        };
        return callback(error);
      }
      if (!hub.uniqueTitle(middleware.title)) {
        error = new Error('notice: cannot insert middleware without unique title');
        error.suggestion = {
          upsert: '[POST,PUT] /hubs/:uuid:/middlewares/:slot:'
        };
        return callback(error);
      }
      try {
        hub.use({
          title: middleware.title,
          description: middleware.description,
          enabled: middleware.enabled
        }, middleware.fn);
      } catch (_error) {
        error = _error;
        return callback(error);
      }
      inserted = hub.serialize(2).middlewares[hub.lastSlot];
      return callback(null, {
        statusCode: 201,
        middleware: inserted
      });
    },
    upsertMiddleware: function(hub, slot, middleware, callback) {
      var error, statusCode, upserted;
      slot = parseInt(slot);
      if ((middleware.slot != null) && slot !== middleware.slot) {
        return callback(new Error('notice: slot mismatch request.body vs url'));
      }
      statusCode = hub.emptySlot(slot) ? 201 : 200;
      try {
        hub.use({
          slot: slot,
          title: middleware.title,
          description: middleware.description,
          enabled: middleware.enabled
        }, middleware.fn);
      } catch (_error) {
        error = _error;
        return callback(error);
      }
      upserted = hub.serialize(2).middlewares[slot];
      return callback(null, {
        statusCode: statusCode,
        middleware: upserted
      });
    }
  };
  local.routes = {
    '/about': {
      description: 'show this',
      methods: ['GET'],
      handler: function(matched, request, response, statusCode) {
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        return local.respond({
          module: 'notice',
          version: Version,
          doc: 'https://github.com/nomilous/notice/tree/master/spec/management',
          endpoints: local.routes
        }, statusCode, response);
      }
    },
    '/hubs': {
      description: 'list present hubs',
      methods: ['GET'],
      handler: function(matched, request, response, statusCode) {
        var hubs, result, uuid;
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        result = {};
        hubs = local.hubContext.hubs;
        for (uuid in hubs) {
          result[uuid] = hubs[uuid].serialize(1);
        }
        return local.respond(result, statusCode, response);
      }
    },
    '/hubs/:uuid:': {
      description: 'get a hub',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var notifier, query, uuid;
        query = _arg[0], uuid = _arg[1];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        return local.respond(notifier.serialize(2), statusCode, response);
      }
    },
    '/hubs/:uuid:/stats': {
      description: 'get only the hub stats',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var notifier, query, uuid;
        query = _arg[0], uuid = _arg[1];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        return local.respond(notifier.serialize(2).stats, statusCode, response);
      }
    },
    '/hubs/:uuid:/errors': {
      description: 'get only the recent errors',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var notifier, query, uuid;
        query = _arg[0], uuid = _arg[1];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        return local.respond(notifier.serialize(2).errors, statusCode, response);
      }
    },
    '/hubs/:uuid:/cache': {
      description: 'get output from a serailization of the traversal cache',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var notifier, query, uuid;
        query = _arg[0], uuid = _arg[1];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        return local.respond(notifier.serialize(2).cache, statusCode, response);
      }
    },
    '/hubs/:uuid:/cache/**/*': {
      description: 'get nested subkey from the cache tree',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var cache, deeper, notifier, query, uuid;
        query = _arg[0], uuid = _arg[1], deeper = _arg[2];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        cache = notifier.serialize(2).cache;
        deeper.split('/').map(function(key) {
          key = decodeURIComponent(key);
          return cache = cache[key];
        });
        return local.respond(cache, statusCode, response);
      }
    },
    '/hubs/:uuid:/tools': {
      description: 'get output from a serailization of the tools tree',
      methods: ['GET'],
      handler: recursor(local, 'tools')
    },
    '/hubs/:uuid:/tools/**/*': {
      description: 'get nested subkey from the tools key',
      methods: ['GET'],
      handler: recursor(local, 'tools')
    },
    '/hubs/:uuid:/middlewares': {
      description: 'get only the middlewares',
      methods: ['GET', 'POST'],
      accepts: ['text/javascript', 'text/coffeescript'],
      handler: function(_arg, _arg1, response, statusCode) {
        var authenticEntity, body, headers, hubuuid, method, nothing, notifier, query;
        query = _arg[0], hubuuid = _arg[1], nothing = _arg[2], authenticEntity = _arg[3];
        method = _arg1.method, headers = _arg1.headers, body = _arg1.body;
        if (statusCode == null) {
          statusCode = 200;
        }
        if (method === 'POST') {
          if (!local.hubContext.hubs[hubuuid]) {
            return local.objectNotFound(response);
          }
          notifier = local.hubContext.hubs[hubuuid];
          return local.middleware('insert', notifier, null, headers['content-type'], body, response, statusCode);
        }
        if (method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[hubuuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[hubuuid];
        return local.respond(notifier.serialize(2).middlewares, statusCode, response);
      }
    },
    '/hubs/:uuid:/middlewares/:slot:': {
      description: 'get or update or delete a middleware',
      methods: ['GET', 'PUT', 'POST'],
      accepts: ['text/javascript', 'text/coffeescript'],
      handler: function(_arg, _arg1, response, statusCode) {
        var authenticEntity, body, headers, hubuuid, method, middlewares, notifier, query, slot;
        query = _arg[0], hubuuid = _arg[1], slot = _arg[2], authenticEntity = _arg[3];
        method = _arg1.method, headers = _arg1.headers, body = _arg1.body;
        if (statusCode == null) {
          statusCode = 200;
        }
        if (method === 'POST' || method === 'PUT') {
          if (!local.hubContext.hubs[hubuuid]) {
            return local.objectNotFound(response);
          }
          notifier = local.hubContext.hubs[hubuuid];
          return local.middleware('upsert', notifier, slot, headers['content-type'], body, response, statusCode);
        }
        if (method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[hubuuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[hubuuid];
        middlewares = notifier.serialize(2).middlewares;
        try {
          return local.respond(middlewares[slot], statusCode, response);
        } catch (_error) {}
        return objectNotFound(response);
      }
    },
    '/hubs/:uuid:/middlewares/:slot:/fn': {
      description: 'show middleware function',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var authenticEntity, fnString, middlewares, notifier, query, slot, uuid;
        query = _arg[0], uuid = _arg[1], slot = _arg[2], authenticEntity = _arg[3];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        middlewares = notifier.serialize(2).middlewares;
        if (middlewares[slot]) {
          fnString = middlewares[slot].fn.toString();
          response.writeHead(200, {
            'Content-Type': 'text/javascript',
            'Content-Length': fnString.length
          });
          return response.end(fnString);
        }
        return objectNotFound(response);
      }
    },
    '/hubs/:uuid:/middlewares/:slot:/disable': {
      description: 'disable a middleware',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var authenticEntity, middlewares, notifier, query, slot, uuid;
        query = _arg[0], uuid = _arg[1], slot = _arg[2], authenticEntity = _arg[3];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        notifier.use({
          slot: slot,
          enabled: false,
          update: true
        });
        middlewares = notifier.serialize(2).middlewares;
        return local.respond(middlewares[slot], statusCode, response);
        return objectNotFound(response);
      }
    },
    '/hubs/:uuid:/middlewares/:slot:/enable': {
      description: 'enable a middleware',
      methods: ['GET'],
      handler: function(_arg, request, response, statusCode) {
        var authenticEntity, middlewares, notifier, query, slot, uuid;
        query = _arg[0], uuid = _arg[1], slot = _arg[2], authenticEntity = _arg[3];
        if (statusCode == null) {
          statusCode = 200;
        }
        if (request.method !== 'GET') {
          return local.methodNotAllowed(response);
        }
        if (!local.hubContext.hubs[uuid]) {
          return local.objectNotFound(response);
        }
        notifier = local.hubContext.hubs[uuid];
        notifier.use({
          slot: slot,
          enabled: true,
          update: true
        });
        middlewares = notifier.serialize(2).middlewares;
        return local.respond(middlewares[slot], statusCode, response);
        return objectNotFound(response);
      }
    }
  };
  port = listen.port;
  address = listen.hostname != null ? listen.hostname : '127.0.0.1';
  opts = {};
  opts.key = listen.key;
  opts.cert = listen.cert;
  _ref = start(opts, local.requestHandler = authenticated(function(authenticEntity, request, response) {
    var body, error;
    body = '';
    error = false;
    request.on('error', function() {
      return error = true;
    });
    request.on('data', function(data) {
      return body += data.toString();
    });
    return request.on('end', function() {
      var action, base, deeper, match, nested, path, query, slot, uuid, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (error) {
        return;
      }
      request.body = body;
      path = request.url;
      try {
        _ref = path.match(/(.*)\?(.*)/), match = _ref[0], path = _ref[1], query = _ref[2];
      } catch (_error) {}
      if (path === '/about' || path === '/') {
        return local.routes["/about"].handler([], request, response);
      }
      if (path.slice(-1) === '/') {
        path = path.slice(0, -1);
      }
      try {
        _ref1 = path.match(/(.*)\/(.*)\/(.*)\/(.*)\/(.*)/), match = _ref1[0], base = _ref1[1], uuid = _ref1[2], nested = _ref1[3], slot = _ref1[4], action = _ref1[5];
        return local.routes["" + base + "/:uuid:/" + nested + "/:slot:/" + action].handler([query, uuid, slot, authenticEntity], request, response);
      } catch (_error) {}
      try {
        _ref2 = path.match(/(.*)\/(.*)\/(.*)\/(.*)/), match = _ref2[0], base = _ref2[1], uuid = _ref2[2], nested = _ref2[3], slot = _ref2[4];
        return local.routes["" + base + "/:uuid:/" + nested + "/:slot:"].handler([query, uuid, slot, authenticEntity], request, response);
      } catch (_error) {}
      try {
        _ref3 = path.match(/(.*)\/(.*)\/(.*)/), match = _ref3[0], base = _ref3[1], uuid = _ref3[2], nested = _ref3[3];
        try {
          if (_ref4 = path.match(/\/hubs\/(.*)\/cache\/(.*)/), match = _ref4[0], uuid = _ref4[1], deeper = _ref4[2], _ref4) {
            return local.routes["/hubs/:uuid:/cache/**/*"].handler([query, uuid, deeper], request, response);
          }
        } catch (_error) {}
        try {
          if (_ref5 = path.match(/\/hubs\/(.*)\/tools\/(.*)/), match = _ref5[0], uuid = _ref5[1], deeper = _ref5[2], _ref5) {
            return local.routes["/hubs/:uuid:/tools/**/*"].handler([query, uuid, deeper, authenticEntity], request, response);
          }
        } catch (_error) {}
        return local.routes["" + base + "/:uuid:/" + nested].handler([query, uuid], request, response);
      } catch (_error) {}
      try {
        _ref6 = path.match(/\/(.*)\/(.*)/), match = _ref6[0], base = _ref6[1], uuid = _ref6[2];
        return local.routes["/" + base + "/:uuid:"].handler([query, uuid], request, response);
      } catch (_error) {}
      try {
        _ref7 = path.match(/\/(.*)/), match = _ref7[0], base = _ref7[1];
        return local.routes["/" + base].handler([query], request, response);
      } catch (_error) {}
      return local.objectNotFound(response);
    });
  })), server = _ref.server, transport = _ref.transport;
  server.listen(port, address, function() {
    var _ref1;
    _ref1 = server.address(), address = _ref1.address, port = _ref1.port;
    return console.log('API @ %s://%s:%s', transport, address, port);
  });
  return api = {
    register: local.register
  };
};
