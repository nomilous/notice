// Generated by CoffeeScript 1.6.3
var recurse, testable;

testable = void 0;

module.exports._recursor = function() {
  return testable;
};

module.exports.recursor = function(local, type) {
  return testable = function(_arg, request, response, statusCode) {
    var deeper, notifier, object, opts, path, searialized, uuid;
    opts = _arg[0], uuid = _arg[1], deeper = _arg[2];
    if (statusCode == null) {
      statusCode = 200;
    }
    if (type === 'tools') {
      opts.root = local;
    } else {
      if (request.method !== 'GET') {
        return local.methodNotAllowed(response);
      }
    }
    if (!local.hubContext.hubs[uuid]) {
      return local.objectNotFound(response);
    }
    notifier = local.hubContext.hubs[uuid];
    searialized = notifier.serialize(2);
    if (searialized[type] == null) {
      return local.objectNotFound(response);
    }
    object = searialized[type];
    path = (function() {
      try {
        return deeper.split('/');
      } catch (_error) {}
    })();
    return recurse(opts, request, object, path, {}, function(error, result) {
      var body;
      if (deeper != null) {
        deeper.split('/').map(function(key) {
          return result = result[key];
        });
      }
      body = JSON.stringify(result, null, 2);
      response.writeHead(statusCode, {
        'Content-Type': 'application/json',
        'Content-Length': body.length
      });
      response.write(body);
      return response.end();
    });
  };
};

recurse = function(opts, request, object, path, result, callback) {
  var key, next;
  request.$root || (request.$root = result);
  request.$callback || (request.$callback = callback);
  try {
    next = path.shift();
  } catch (_error) {}
  for (key in object) {
    if (next != null) {
      if (key !== next) {
        continue;
      }
    }
    switch (typeof object[key]) {
      case 'object':
        result[key] = {};
        recurse(opts, request, object[key], path, result[key]);
        break;
      case 'number':
      case 'string':
        result[key] = object[key];
        break;
      case 'function':
        if (object[key].$notice != null) {
          if (next == null) {
            result[key] = {};
            continue;
          }
          request.$walking = true;
          return object[key](opts, function(error, nested) {
            result[key] = nested;
            if (typeof request.$callback === 'function') {
              return request.$callback(null, request.$root);
            }
          });
        }
    }
  }
  if ((request.$walking == null) && typeof callback === 'function') {
    return callback(null, result);
  }
};
